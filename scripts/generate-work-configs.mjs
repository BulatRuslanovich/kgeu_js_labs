#!/usr/bin/env node

import fs from "fs/promises";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");
const showcaseDir = path.join(repoRoot, "showcase");
const generatedFile = path.join(showcaseDir, "workConfigs.generated.js");

const worksModuleUrl = path.join(showcaseDir, "works.js");
const worksModule = await import(pathToFileURL(worksModuleUrl));
const works = worksModule.default ?? worksModule;

const extractFirstComment = (content) => {
  const lines = content.split(/\r?\n/);
  let inBlock = false;
  const commentLines = [];

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    if (!inBlock && line.startsWith("//")) {
      return line.replace(/^\/\/+\s?/, "").trim() || "-";
    }

    if (!inBlock && line.startsWith("/*")) {
      inBlock = true;
      const stripped = line.replace(/^\/\*+\s?/, "");
      if (stripped.includes("*/")) {
        return stripped.replace(/\*\/.*/, "").trim() || "-";
      }
      if (stripped) commentLines.push(stripped);
      continue;
    }

    if (inBlock) {
      if (line.includes("*/")) {
        inBlock = false;
        commentLines.push(line.replace(/\*\/.*/, ""));
        break;
      }
      commentLines.push(line);
      continue;
    }

    break;
  }

  if (commentLines.length > 0) {
    return commentLines.join(" ").trim() || "-";
  }

  return "-";
};

const stringify = (value) => JSON.stringify(value);

const configLines = [];
configLines.push(
  "// This file is auto-generated by scripts/generate-work-configs.mjs",
);
configLines.push("// Do not edit manually.");
configLines.push("");
configLines.push("const workConfigs = {");

for (const work of works) {
  if (!work.directory) {
    throw new Error(
      `Work "${work.id}" is missing the "directory" property in works.js.`,
    );
  }

  const workDir = path.resolve(repoRoot, work.directory);

  const entries = await fs.readdir(workDir);
  const hasPdf = entries.includes("tasks.pdf");
  const jsFiles = entries
    .filter((name) => /^task\d+\.js$/i.test(name))
    .sort(
      (a, b) =>
        parseInt(a.match(/\d+/)[0], 10) - parseInt(b.match(/\d+/)[0], 10),
    );

  const tasks = [];

  for (const file of jsFiles) {
    const id = file.replace(/\.js$/i, "");
    const filePath = path.join(workDir, file);
    const content = await fs.readFile(filePath, "utf8");
    const title = extractFirstComment(content);

    tasks.push({ id, title, file });
  }

  configLines.push(`  '${work.id}': {`);
  configLines.push(`    id: '${work.id}',`);
  configLines.push(`    title: ${stringify(work.title)},`);
  configLines.push(`    description: ${stringify(work.description ?? "-")},`);
  if (hasPdf) {
    configLines.push("    tasksPdf: 'tasks.pdf',");
  }
  configLines.push("    tasks: [");

  for (const task of tasks) {
    configLines.push("      {");
    configLines.push(`        id: '${task.id}',`);
    configLines.push(`        title: ${stringify(task.title)},`);
    configLines.push(`        file: '${task.file}',`);
    configLines.push("      },");
  }

  configLines.push("    ],");
  configLines.push("  },");
}

configLines.push("};");
configLines.push("");
configLines.push("export default workConfigs;");
configLines.push("");

await fs.writeFile(generatedFile, configLines.join("\n"), "utf8");

console.log(`Generated ${path.relative(repoRoot, generatedFile)}`);
