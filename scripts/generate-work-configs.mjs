#!/usr/bin/env node

import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");
const showcaseDir = path.join(repoRoot, "showcase");
const generatedFile = path.join(showcaseDir, "workConfigs.generated.js");

const dirEntries = await fs.readdir(repoRoot, { withFileTypes: true });

const workDirs = dirEntries
  .filter(
    (entry) =>
      entry.isDirectory() && /^(?:lab|prac)_\d+$/i.test(entry.name ?? ""),
  )
  .map((entry) => entry.name)
  .sort((a, b) => {
    const typeOrder = (name) =>
      name.startsWith("lab_")
        ? 0
        : name.startsWith("prac_")
        ? 1
        : 2;
    const typeDiff = typeOrder(a) - typeOrder(b);
    if (typeDiff !== 0) return typeDiff;

    const numA = Number(a.match(/\d+/)?.[0] ?? 0);
    const numB = Number(b.match(/\d+/)?.[0] ?? 0);
    if (numA !== numB) return numA - numB;

    return a.localeCompare(b);
  });

const buildTitle = (name) => {
  const match = name.match(/^(lab|prac)_(\d+)$/i);
  if (!match) return name;

  const [, kindRaw, numberRaw] = match;
  const number = Number(numberRaw);

  if (kindRaw.toLowerCase() === "lab") {
    return `Лаба ${number}`;
  }

  if (kindRaw.toLowerCase() === "prac") {
    return `Практика ${number}`;
  }

  return name;
};

const works = workDirs.map((directory) => ({
  id: directory,
  directory,
  title: buildTitle(directory),
}));

const extractFirstComment = (content) => {
  const lines = content.split(/\r?\n/);
  let inBlock = false;
  const commentLines = [];

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    if (!inBlock && line.startsWith("//")) {
      return line.replace(/^\/\/+\s?/, "").trim() || "-";
    }

    if (!inBlock && line.startsWith("/*")) {
      inBlock = true;
      const stripped = line.replace(/^\/\*+\s?/, "");
      if (stripped.includes("*/")) {
        return stripped.replace(/\*\/.*/, "").trim() || "-";
      }
      if (stripped) commentLines.push(stripped);
      continue;
    }

    if (inBlock) {
      if (line.includes("*/")) {
        inBlock = false;
        commentLines.push(line.replace(/\*\/.*/, ""));
        break;
      }
      commentLines.push(line);
      continue;
    }

    break;
  }

  if (commentLines.length > 0) {
    return commentLines.join(" ").trim() || "-";
  }

  return "-";
};

const stringify = (value) => JSON.stringify(value);

const configLines = [];
configLines.push(
  "// This file is auto-generated by scripts/generate-work-configs.mjs",
);
configLines.push("// Do not edit manually.");
configLines.push("");
configLines.push("const workConfigs = {");

for (const work of works) {
  const workDir = path.resolve(repoRoot, work.directory);

  const entries = await fs.readdir(workDir);
  const hasPdf = entries.includes("tasks.pdf");
  const jsFiles = entries
    .filter((name) => /^task\d+\.js$/i.test(name))
    .sort(
      (a, b) =>
        parseInt(a.match(/\d+/)[0], 10) - parseInt(b.match(/\d+/)[0], 10),
    );

  const tasks = [];

  for (const file of jsFiles) {
    const id = file.replace(/\.js$/i, "");
    const filePath = path.join(workDir, file);
    const content = await fs.readFile(filePath, "utf8");
    const title = extractFirstComment(content);

    tasks.push({ id, title, file });
  }

  configLines.push(`  '${work.id}': {`);
  configLines.push(`    id: '${work.id}',`);
  configLines.push(`    title: ${stringify(work.title)},`);
  configLines.push(`    directory: ${stringify(work.directory)},`);

  if (hasPdf) {
    configLines.push("    tasksPdf: true,");
  }

  configLines.push("    tasks: [");

  for (const task of tasks) {
    configLines.push("      {");
    configLines.push(`        id: '${task.id}',`);
    configLines.push(`        title: ${stringify(task.title)},`);
    configLines.push(`        file: '${task.file}',`);
    configLines.push("      },");
  }

  configLines.push("    ],");
  configLines.push("  },");
}

configLines.push("};");
configLines.push("");
configLines.push("export default workConfigs;");
configLines.push("");

await fs.writeFile(generatedFile, configLines.join("\n"), "utf8");

console.log(`Generated ${path.relative(repoRoot, generatedFile)}`);
